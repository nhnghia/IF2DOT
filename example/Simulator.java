
import java.io.*;
import java.lang.reflect.Field;
import java.util.*;

/**
 * {@link https://github.com/nhnghia/IF2DOT/tree/2java}
 * @author nhnghia
 *
 */
public class Simulator {
	/**
	 * to be overridden by extended class 
	 */
	public String getSystemName(){
		return "Simulator";
	}
	
	/**
	 * 
	 */
	public String getInitStateName(){
		return "init";
	}
	//Data type definition
	public static abstract class Event{}
	public static abstract class Signal extends Event{
		/**
		 * source and destination defined in model
		 */
		public static String source, destination;
		/**
		 * source and destination defined in test case
		 */
		public String realSource, realDestination;
		public Object param;
		public boolean isInput;
		
		public String toString(){
			String str = "!";
			if (isInput)
				str = "?";
			str = String.format("%s	%s	%s{%s}	%s", str, realSource, this.getClass().getSimpleName(), param, realDestination);
			return str;
		}
		
		public boolean isLike(Class<?> cls){
			if (! this.getClass().equals(cls))
				return false;
			return true;
		}
	}
	public static class Delay extends Event{
		public int delay;
		public String toString(){
			return "delay	" + delay;
		}
	}
	
	//virtual methods to be implemented in generated class
	public void updateClock(int val){}
	protected void callState(String stateName){}
	public void state_init(){}

	
	int currentEventIndex;
	List<Event> eventList;
	Set<String> expectedSignalsAtState;	//when no outgoing trans of a state can be fired, this list contains its expected in/output signals
	boolean verdict;
	
	
	/**
	 * This method is called when no outgoing transition of state {@code stateName} can be fired
	 * @param stateName
	 */
	protected void noFire(String stateName){
		verdict = false;
		
		System.out.println(" - End at state: " + stateName);
		System.out.println(" - Simulator expects input/outputs: ");
		
		Iterator<String> i = expectedSignalsAtState.iterator();
		while (i.hasNext()){
			String name = (String) i.next();
		    System.out.println(name + "   ");
		}
		
		System.out.println(" - Expected event: " + getCurrentSignal());
	}
	
	protected void nextState(String stateName){
		
		if (verdict == false){
			return;
		}
		
		//all events in test case are executed 
		if (currentEventIndex >= eventList.size()){
			System.out.println("All events in the test case are executed successfully");
			return;
		}
		
		//continue executing only if input/delay/output conform to test case
		System.out.println("====" + stateName + "================");
				
		Event ev = eventList.get(currentEventIndex);
		if (ev instanceof Delay){
			Delay delay = (Delay) ev;
			updateClock(delay.delay);
		}
		
		//the list is reset at begining each state;
		expectedSignalsAtState = null;
		expectedSignalsAtState = new HashSet<String>();
		
		callState(stateName);
	}
	/**
	 * get current input
	 * @param signalClass
	 * @param objClass
	 * @return NULL if current input is not instanceof signalClass
	 */
	protected Object getInput(Class<?> signalClass, Class<?> objClass){
		expectedSignalsAtState.add("? " + signalClass.getSimpleName());
		
		Signal ev = getCurrentSignal();
		if (! ev.isInput){
			return null;
		}
			
		if (ev.isLike(signalClass)){
			System.out.println(ev);
			currentEventIndex ++;
			
			return ((Signal)ev).param;
		}
		return null;
	}
	
	protected void output(Class<?> signalClass, Object var){
		Signal ev = getCurrentSignal();
		
		if (ev.isLike(signalClass) && ev.param.equals(var)){
			System.out.println(ev);
			currentEventIndex ++;
			return;
		}
		
		if (ev.isInput){
			System.out.println(" - Fail Output: Input: " + ev.getClass().getSimpleName() + ", Expected an output: " + signalClass.getSimpleName());
			verdict = false;
			return;
		}
		
		System.out.println(" - Fail output:\n	+ Output: " + signalClass.getSimpleName() + "{" + var + "}");
		System.out.println("	+ Expected: " + ev);
		verdict = false;
	}
	
	/**
	 * Run simulator on the list of events
	 * @param testCase path to file containing test case
	 * @return return true (pass) if<br/>
	 *  + all inputs and delays of {@code lst} are executed<br/>
	 *  + and all outputs of {@code lst} and the ones of simulator are the same <br/>
	 * otherwise return false (fail)
	 * @throws Exception 
	 */
	public boolean run(String testCase) throws Exception{
		currentEventIndex = 0;
		eventList = getTestCases(testCase);
		verdict = true;
		
		nextState(getInitStateName());// --> nextState() --> callState()	--> state_...()
		
		return verdict;
	}
	
	
	/**
	 * Exception when parser a test case generated by TestGen-IFx ({@link https://github.com/nhnghia/TestGen-IFx})
	 * @author nhnghia
	 *
	 */
	public static class TestCaseParserException extends Exception{
		private static final long serialVersionUID = 1L;
		public String line;
		public TestCaseParserException(String l){
			line = l;
		}
	}
	
	
	/**
	 * get event list from a test case file
	 * @param path
	 * @return
	 * @throws TestCaseParserException
	 * @throws IOException 
	 * @throws IllegalAccessException 
	 * @throws InstantiationException 
	 * @throws ClassNotFoundException 
	 */
	public List<Event> getTestCases(String path) throws TestCaseParserException, IOException, ClassNotFoundException, InstantiationException, IllegalAccessException{
		List<Event> lst = new ArrayList<Event>();
		
		BufferedReader br = new BufferedReader(new FileReader(path));
		String line;
		while ((line = br.readLine()) != null) {
				lst.add(parserTestCase(line));
		}
		br.close();
		
		return lst;
	}
	
	/**
	 * Parser an event from a string
	 * @param str, e.g., "!;	t;	 ELocation{0};	{OBU}0"
	 * @return
	 * @throws ClassNotFoundException 
	 * @throws SecurityException 
	 * @throws IllegalAccessException 
	 */
	public Event parserTestCase(String str) throws ClassNotFoundException, InstantiationException, IllegalAccessException, TestCaseParserException{
		if (str.startsWith("delay")){
			Delay delay = new Delay();
			delay.delay = Integer.parseInt(str.split(" ", -1)[1]);
			return delay;
		}
		String[] s = str.split(";\t", -1);
		String type = s[0],
				src = s[1], 
				dst = s[3],
				className = s[2].split("\\{")[0].trim(),
				data = s[2].substring(className.length());
		
		Class<?> cls = Class.forName(getSystemName() + "$" + className);
		Signal ev = (Signal) cls.newInstance();
		ev.isInput = type.equals("?");
		
		//inverse event direction when it from/to tester t
		if (src.equals("t") || dst.equals("t")){
			ev.isInput = ! ev.isInput;
		}
		
		ev.realSource = getContentInside(src);
		ev.realDestination = getContentInside(dst);
		
		//create param
		Field fields[] = cls.getFields();
		for (int i=0; i<fields.length; i++){
			if (fields[i].getName().equals("param")){
				ev.param = getValue(fields[i].getType(), data);
				break;
			}
		}
			
		return ev;
	}
	
	
	/**
	 * Create an object with type of {@code type} with value {@code data}
	 * @param type
	 * @param data
	 * @return
	 * @throws TestCaseParserException
	 * @throws IllegalAccessException 
	 * @throws InstantiationException 
	 */
	private Object getValue(Class<?> type, String data) throws TestCaseParserException, InstantiationException, IllegalAccessException{
		data = getContentInside(data);
		if (type.getSimpleName().equals("Integer")){
			Integer obj = Integer.parseInt(data);
			return obj;
		}
		else if (type.getSimpleName().equals("String")){
			return data;
		}
		
		//MA{{0,80}}
		//data = {0,80}
		if (! data.startsWith("{"))
			throw new TestCaseParserException(data);
		
		
		data = getContentInside(data);
		String [] str = data.split(",");
		Object obj = type.newInstance();
		
		Field fields[] = type.getFields();
		if (fields.length != str.length)
			throw new TestCaseParserException(data);
		
		for (int i=0; i<fields.length; i++){
				fields[i].set(obj, getValue(fields[i].getType(), str[i]));;
		}
		
		return obj;
	}
	/**
	 * 
	 * @param str: {OBU}0
	 * @return "OBU"
	 */
	private String getContentInside(String str){
		if (str.indexOf("{") == -1)
			return str;
		
		str = str.substring(str.indexOf("{"));
		//find the } corresponding
		int d = 0, index = 0;
		for (index=0; index <str.length(); index ++){
			switch (str.charAt(index)) {
				case '{' : d ++;
							break;
				case '}' : d --;
							break;
			}
			if (d <= 0)
				break;
		}
		str = str.substring(1, index);
		return str;
	}
	
	Signal getCurrentSignal(){
		if (currentEventIndex >= eventList.size())
			return null;
		Event ev = eventList.get(currentEventIndex);
		
		//update clocks of simulator when Delay
		while (ev instanceof Delay){
			Delay d = (Delay) ev;
			System.out.println(d);
			updateClock(d.delay);
			ev = eventList.get(++ currentEventIndex);
		}
		return (Signal) ev;
	}
	
}
